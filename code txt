// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

interface IERC20Minimal {
    function totalSupply() external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from,address to,uint256 amount) external returns (bool);
    function approve(address spender,uint256 amount) external returns (bool);
    function allowance(address owner,address spender) external view returns (uint256);
    event Transfer(address indexed from,address indexed to,uint256 value);
    event Approval(address indexed owner,address indexed spender,uint256 value);
}

contract ERC20Minimal is IERC20Minimal {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public override totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    constructor(string memory _name,string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function balanceOf(address owner) public view override returns (uint256) {
        return _balances[owner];
    }

    function transfer(address to,uint256 amount) public override returns (bool) {
        _transfer(msg.sender,to,amount);
        return true;
    }

    function allowance(address owner,address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender,uint256 amount) public override returns (bool) {
        _approve(msg.sender,spender,amount);
        return true;
    }

    function transferFrom(address from,address to,uint256 amount) public override returns (bool) {
        uint256 currentAllowance = _allowances[from][msg.sender];
        require(currentAllowance >= amount,"ERC20: transfer amount exceeds allowance");
        _transfer(from,to,amount);
        _approve(from,msg.sender,currentAllowance - amount);
        return true;
    }

    function _transfer(address from,address to,uint256 amount) internal {
        require(from != address(0),"ERC20: transfer from zero");
        require(to != address(0),"ERC20: transfer to zero");

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount,"ERC20: transfer exceeds balance");
        _balances[from] = fromBalance - amount;
        _balances[to] += amount;

        emit Transfer(from,to,amount);
    }

    function _mint(address to,uint256 amount) internal {
        require(to != address(0),"ERC20: mint to zero");
        totalSupply += amount;
        _balances[to] += amount;
        emit Transfer(address(0),to,amount);
    }

    function _burn(address from,uint256 amount) internal {
        require(from != address(0),"ERC20: burn from zero");
        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount,"ERC20: burn exceeds balance");
        _balances[from] = fromBalance - amount;
        totalSupply -= amount;
        emit Transfer(from,address(0),amount);
    }

    function _approve(address owner,address spender,uint256 amount) internal {
        require(owner != address(0),"ERC20: approve from zero");
        require(spender != address(0),"ERC20: approve to zero");
        _allowances[owner][spender] = amount;
        emit Approval(owner,spender,amount);
    }
}

contract TradersharingPair is ERC20Minimal {
    address public token0;
    address public token1;
    address public factory;
    address public router; // ✅ Tambahan baru

    uint112 private reserve0;
    uint112 private reserve1;
    uint32 private blockTimestampLast;

    uint public constant MINIMUM_LIQUIDITY = 10**3;

    constructor() ERC20Minimal("Tradersharing LP Token","TS-LP") {
        factory = msg.sender;
    }

    function setRouter(address _router) external { // ✅ Tambahan baru
        require(msg.sender == factory, "Only factory can set router");
        require(router == address(0), "Router already set");
        router = _router;
    }

    function initialize(address _tokenA,address _tokenB) external {
        require(msg.sender == factory,"Only factory");
        (token0,token1) = _tokenA < _tokenB ? (_tokenA,_tokenB) : (_tokenB,_tokenA);
    }

    function getReserves() external view returns (uint112,uint112) {
        return (reserve0,reserve1);
    }

    function _update(uint balance0,uint balance1) private {
        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max,"Overflow");
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        blockTimestampLast = uint32(block.timestamp % 2**32);
    }

    function mint(address to) external returns (uint liquidity) {
        require(msg.sender == factory || msg.sender == router, "Only factory or router"); // ✅
        uint balance0 = IERC20Minimal(token0).balanceOf(address(this));
        uint balance1 = IERC20Minimal(token1).balanceOf(address(this));
        uint amount0 = balance0 - reserve0;
        uint amount1 = balance1 - reserve1;

        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;
            _mint(address(0), MINIMUM_LIQUIDITY);
        } else {
            liquidity = min((amount0 * _totalSupply) / reserve0,(amount1 * _totalSupply) / reserve1);
        }
        require(liquidity > 0,"Insufficient liquidity");
        _mint(to, liquidity);
        _update(balance0,balance1);
    }

    function burn(address to) external returns (uint amount0,uint amount1) {
        require(msg.sender == factory || msg.sender == router, "Only factory or router"); // ✅
        uint liquidity = balanceOf(address(this));
        uint _totalSupply = totalSupply;

        uint balance0 = IERC20Minimal(token0).balanceOf(address(this));
        uint balance1 = IERC20Minimal(token1).balanceOf(address(this));

        amount0 = (liquidity * balance0) / _totalSupply;
        amount1 = (liquidity * balance1) / _totalSupply;

        require(amount0 > 0 && amount1 > 0,"Insufficient liquidity burn");

        _burn(address(this), liquidity);
        require(IERC20Minimal(token0).transfer(to,amount0),"Transfer token0 failed");
        require(IERC20Minimal(token1).transfer(to,amount1),"Transfer token1 failed");

        _update(
            IERC20Minimal(token0).balanceOf(address(this)),
            IERC20Minimal(token1).balanceOf(address(this))
        );
    }

    function swap(uint amount0Out,uint amount1Out,address to) external {
        require(msg.sender == factory || msg.sender == router, "Only factory or router"); // ✅
        require(amount0Out > 0 || amount1Out > 0,"Insufficient output");

        (uint112 _reserve0,uint112 _reserve1) = (reserve0,reserve1);
        require(amount0Out < _reserve0 && amount1Out < _reserve1,"Insufficient liquidity");

        if(amount0Out > 0) IERC20Minimal(token0).transfer(to, amount0Out);
        if(amount1Out > 0) IERC20Minimal(token1).transfer(to, amount1Out);

        _update(
            IERC20Minimal(token0).balanceOf(address(this)),
            IERC20Minimal(token1).balanceOf(address(this))
        );
    }

    function min(uint x,uint y) private pure returns (uint) {
        return x < y ? x : y;
    }

    function sqrt(uint y) private pure returns (uint z) {
        if(y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while(x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if(y != 0) {
            z = 1;
        }
    }
}


contract Tradersharingfactory {
    mapping(address => mapping(address => address)) public getPair;
    address[] public allPairs;

    event PairCreated(address indexed token0,address indexed token1,address pair,uint);

    function createPair(address tokenA,address tokenB) external returns (address pair) {
        require(tokenA != tokenB,"Identical addresses");
        (address token0,address token1) = tokenA < tokenB ? (tokenA,tokenB) : (tokenB,tokenA);
        require(token0 != address(0),"Zero address");
        require(getPair[token0][token1] == address(0),"Pair exists");

        bytes memory bytecode = type(TradersharingPair).creationCode;
        bytes32 salt = keccak256(abi.encodePacked(token0,token1));
        assembly {
            pair := create2(0,add(bytecode,32),mload(bytecode),salt)
        }

        TradersharingPair(pair).initialize(token0,token1);

        getPair[token0][token1] = pair;
        getPair[token1][token0] = pair;
        allPairs.push(pair);

        emit PairCreated(token0,token1,pair,allPairs.length);
    }

    function allPairsLength() external view returns (uint) {
        return allPairs.length;
    }
}
